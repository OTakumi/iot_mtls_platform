# 開発ロードマップ

## Phase 1: インフラとDB接続の確立（土台作り）

まずはコードを動かすための環境を構築する。
物理分割したDB構成を立ち上げる。

- [x] 1-1. Docker Compose整備:
  - db-auth (PostgreSQL), db-telemetry (PostgreSQL), backend (Go) の3つが起動し、ネットワーク疎通できる状態にする。

- [x] 1-2. DBマイグレーション:
  - 以前作成したER図に基づき、それぞれのDBにテーブルを作成するSQL（またはGo migrate）を用意し、起動時に適用されるようにする。

- 1-3. リポジトリ実装 (Go):
  - 作成したValue ObjectをDBに保存・取得するための Repository 層を実装する。

ゴール: テストコード上で、Deviceの保存と取得、SensorDataの保存が成功すること。

## Phase 2: デバイスの「鍵生成」と「CSR作成」（クライアント実装）

ここがこのシステムのハイライトです。Rust側でOpenSSL等を使わず、安全に鍵を扱う処理を実装します。

- 2-1. Rust環境構築:
  - device-simulator コンテナの作成。

- 2-2. 鍵ペアの生成:
  - Rustの rcgen や openssl クレートを使い、RSAまたはECDSAの秘密鍵をメモリ上（または模擬TPM）で生成する処理。

- 2-3. CSR (署名要求) の生成:
  - 生成した鍵でCSRを作成し、Base64エンコードして出力できるところまで実装。

## Phase 3: プロビジョニングAPIの実装（認証の核心）

デバイスから送られてきたCSRを受け取り、サーバー側で署名して返すフローです。

- 3-1. プライベートCAの実装 (Go):
  - Goの crypto/x509 を使い、サーバー自身の「ルート証明書」で、受け取ったCSRに署名し、クライアント証明書（PEM）を発行するロジック。

- 3-2. プロビジョニングAPIエンドポイント:
  - POST /api/provision を実装。
  - トークン検証 → CSR検証 → 署名 → 証明書返却 の流れを完成させる。

- 3-3. 結合テスト:
  - Rustデバイスが起動 → APIを叩く → 証明書を取得して保存する、までの自動化。

## Phase 4: MQTT通信とデータ保存（データプレーン）

証明書を持ったデバイスが、実際にデータを送るフェーズです。

- 4-1. MosquittoのmTLS設定:
  - mosquitto.conf を編集し、Phase 3で作ったCA証明書以外からの接続を拒否する設定を入れる。

- 4-2. Rust MQTTクライアント:
  - 取得した証明書を使って paho-mqtt 等でブローカーに接続し、JSONデータをPublishする。

- 4-3. バックエンドWorker実装:
  - GoでMQTTをSubscribeし、メッセージを受け取ったら Sensor DB へ保存する処理。

## Phase 5: 管理機能とドキュメント（アピール力強化）

最後に、運用・保守性を高める機能を追加します。

- 5-1. 失効管理 (Revocation):
  - 特定のデバイスIDを指定すると証明書を無効化（DB更新）する機能。余裕があればCRLの生成。

- 5-2. 監査ログ:
  - プロビジョニング時などに audit_logs テーブルへ記録する処理。

- 5-3. README / Architecture Decision Records (ADR):
  - 「なぜDBを分けたか」「なぜRustを選んだか」をドキュメント化。
