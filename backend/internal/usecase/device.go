package usecase

import (
	"context"
	"errors"
	"fmt"
	"gorm.io/gorm"

	"github.com/google/uuid"

	"backend/internal/domain/entity"
	"backend/internal/domain/repository"
)

// DeviceUsecase defines the interface for application-specific business logic related to devices.
type DeviceUsecase interface {
	// CreateDevice registers a new device.
	CreateDevice(ctx context.Context, input CreateDeviceInput) (*DeviceOutput, error)
	// GetDevice retrieves a device by its ID.
	GetDevice(ctx context.Context, id uuid.UUID) (*DeviceOutput, error)
	// ListDevices retrieves all devices.
	ListDevices(ctx context.Context) ([]*DeviceOutput, error)
	// UpdateDevice updates an existing device.
	UpdateDevice(ctx context.Context, input UpdateDeviceInput) (*DeviceOutput, error)
	// DeleteDevice deletes a device by its ID.
	DeleteDevice(ctx context.Context, id uuid.UUID) error
}

// deviceUsecase is the implementation of the DeviceUsecase interface.
type deviceUsecase struct {
	deviceRepo repository.DeviceRepository
}

// NewDeviceUsecase creates a new instance of deviceUsecase.
//
//nolint:ireturn
func NewDeviceUsecase(repo repository.DeviceRepository) DeviceUsecase {
	return &deviceUsecase{deviceRepo: repo}
}

// CreateDevice registers a new device.
func (uc *deviceUsecase) CreateDevice(ctx context.Context, input CreateDeviceInput) (*DeviceOutput, error) {
	// Create a domain entity.
	// The ID is generated by the database, so uuid.Nil is acceptable here.
	var namePtr *string
	if input.Name != "" {
		namePtr = &input.Name
	}

	device, err := entity.NewDevice(input.HardwareID, namePtr, input.Metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to create new device entity: %w", err)
	}

	// Save via the repository.
	err = uc.deviceRepo.Save(ctx, device)
	if err != nil {
		return nil, fmt.Errorf("%w: %w", ErrRepositorySave, err)
	}

	return NewDeviceOutput(device), nil // Convert to output DTO and return.
}

// GetDevice retrieves a device by its ID.
func (uc *deviceUsecase) GetDevice(ctx context.Context, id uuid.UUID) (*DeviceOutput, error) {
	device, err := uc.deviceRepo.FindByID(ctx, id)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, entity.ErrDeviceNotFound
		}

		return nil, fmt.Errorf("%w: %w", ErrDBFindByID, err)
	}

	return NewDeviceOutput(device), nil
}

// ListDevices retrieves all devices.
func (uc *deviceUsecase) ListDevices(ctx context.Context) ([]*DeviceOutput, error) {
	devices, err := uc.deviceRepo.FindAll(ctx)
	if err != nil {
		return nil, fmt.Errorf("%w: %w", ErrDBFindAll, err)
	}

	outputs := make([]*DeviceOutput, 0, len(devices))

	for _, device := range devices {
		outputs = append(outputs, NewDeviceOutput(device))
	}

	return outputs, nil
}

// UpdateDevice updates an existing device.
func (uc *deviceUsecase) UpdateDevice(ctx context.Context, input UpdateDeviceInput) (*DeviceOutput, error) {
	// Find the device to be updated.
	device, err := uc.deviceRepo.FindByID(ctx, input.ID)
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, entity.ErrDeviceNotFound
		}

		return nil, fmt.Errorf("%w: %w", ErrDBFindByID, err)
	}

	// Update the entity's values.
	// HardwareID is device-specific and should not be updated.
	// input.Name is a *string, so check for nil.
	if input.Name != nil {
		device.Name = *input.Name
	}

	// input.Metadata is a map, so check for nil.
	if input.Metadata != nil {
		device.Metadata = input.Metadata
	}

	// Update via the repository.
	err = uc.deviceRepo.Save(ctx, device)
	if err != nil {
		return nil, fmt.Errorf("%w: %w", ErrRepositorySave, err)
	}

	return NewDeviceOutput(device), nil
}

// DeleteDevice deletes a device by its ID.
func (uc *deviceUsecase) DeleteDevice(ctx context.Context, id uuid.UUID) error {
	err := uc.deviceRepo.Delete(ctx, id)
	if err != nil {
		return fmt.Errorf("%w: %w", ErrDBDelete, err)
	}

	return nil
}
