package usecase_test

import (
	"context"
	"sort"
	"sync"
	"testing"
	"time"

	"backend/internal/domain/entity"
	"backend/internal/usecase"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// FakeDeviceRepository is an in-memory implementation of the DeviceRepository for testing.
type FakeDeviceRepository struct {
	mu      sync.RWMutex
	devices map[uuid.UUID]*entity.Device
	// for controlling error case
	SaveErr    error
	FindErr    error
	FindAllErr error
	DeleteErr  error
}

// NewFakeDeviceRepository creates a new FakeDeviceRepository.
func NewFakeDeviceRepository() *FakeDeviceRepository {
	return &FakeDeviceRepository{
		mu:         sync.RWMutex{},
		devices:    make(map[uuid.UUID]*entity.Device),
		SaveErr:    nil,
		FindErr:    nil,
		FindAllErr: nil,
		DeleteErr:  nil,
	}
}

// Save adds or updates a device in the in-memory store.
func (r *FakeDeviceRepository) Save(_ context.Context, device *entity.Device) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if r.SaveErr != nil {
		return r.SaveErr
	}

	if device.ID == uuid.Nil {
		device.ID = uuid.New()
	}

	r.devices[device.ID] = device

	return nil
}

// FindByID retrieves a device by its ID from the in-memory store.
func (r *FakeDeviceRepository) FindByID(_ context.Context, id uuid.UUID) (*entity.Device, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	if r.FindErr != nil {
		return nil, r.FindErr
	}

	device, ok := r.devices[id]
	if !ok {
		return nil, entity.ErrDeviceNotFound
	}

	return device, nil
}

// FindByHardwareID retrieves a device by its hardware ID from the in-memory store.
func (r *FakeDeviceRepository) FindByHardwareID(_ context.Context, hardwareID string) (*entity.Device, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	if r.FindErr != nil {
		return nil, r.FindErr
	}

	for _, device := range r.devices {
		if device.HardwareID == hardwareID {
			return device, nil
		}
	}

	return nil, entity.ErrDeviceNotFound
}

// FindAll retrieves all devices from the in-memory store.
func (r *FakeDeviceRepository) FindAll(_ context.Context) ([]*entity.Device, error) {
	r.mu.RLock()
	defer r.mu.RUnlock()

	if r.FindAllErr != nil {
		return nil, r.FindAllErr
	}

	devices := make([]*entity.Device, 0, len(r.devices))
	for _, device := range r.devices {
		devices = append(devices, device)
	}

	return devices, nil
}

// Delete removes a device from the in-memory store.
func (r *FakeDeviceRepository) Delete(_ context.Context, id uuid.UUID) error {
	r.mu.Lock()
	defer r.mu.Unlock()

	if r.DeleteErr != nil {
		return r.DeleteErr
	}

	if _, ok := r.devices[id]; !ok {
		return entity.ErrDeviceNotFound
	}

	delete(r.devices, id)

	return nil
}

// TestCreateDevice tests the CreateDevice method.
func TestCreateDevice(t *testing.T) {
	t.Parallel()

	ctx := context.Background()

	tests := []struct {
		name          string
		desc          string
		input         usecase.CreateDeviceInput
		repoSetup     func(*FakeDeviceRepository)
		wantOutput    *usecase.DeviceOutput
		wantErr       bool
		wantErrString string
	}{
		{
			name: "success: create a new device",
			desc: "Verify that a new device is created and a corresponding output DTO is returned with valid input.",
			input: usecase.CreateDeviceInput{
				HardwareID: "hw-create-001",
				Name:       "Test Device C",
				Metadata:   map[string]any{"os": "linux"},
			},
			repoSetup: nil, // No setup needed for success case
			wantOutput: &usecase.DeviceOutput{
				ID:         uuid.Nil, // ID is generated by the repository
				HardwareID: "hw-create-001",
				Name:       "Test Device C",
				Metadata:   map[string]any{"os": "linux"},
				CreatedAt:  time.Time{}, // Not checked in this test
				UpdatedAt:  time.Time{}, // Not checked in this test
			},
			wantErr:       false,
			wantErrString: "",
		},
		{
			name: "failure: repository returns an error",
			desc: "Verify that the use case returns an error when the repository's Save method returns an error.",
			input: usecase.CreateDeviceInput{
				HardwareID: "hw-err-001",
				Name:       "Error Device",
				Metadata:   nil,
			},
			repoSetup: func(repo *FakeDeviceRepository) {
				repo.SaveErr = usecase.ErrRepositorySave
			},
			wantOutput:    nil,
			wantErr:       true,
			wantErrString: "repository save error",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			fakeRepo := NewFakeDeviceRepository()
			if tt.repoSetup != nil {
				tt.repoSetup(fakeRepo)
			}

			uc := usecase.NewDeviceUsecase(fakeRepo)

			got, err := uc.CreateDevice(ctx, tt.input)

			if tt.wantErr {
				require.Error(t, err)

				if tt.wantErrString != "" {
					require.Contains(t, err.Error(), tt.wantErrString)
				}

				require.Nil(t, got)
			} else {
				require.NoError(t, err)
				require.NotNil(t, got)
				require.NotEqual(t, uuid.Nil, got.ID)
				require.Equal(t, tt.wantOutput.HardwareID, got.HardwareID)
				require.Equal(t, tt.wantOutput.Name, got.Name)
				require.Equal(t, tt.wantOutput.Metadata, got.Metadata)

				// Check the state of the fake repository
				savedDevice, findErr := fakeRepo.FindByID(ctx, got.ID)
				require.NoError(t, findErr)
				require.NotNil(t, savedDevice)
				require.Equal(t, got.ID, savedDevice.ID)
			}
		})
	}
}

// TestGetDevice tests the GetDevice method.
func TestGetDevice(t *testing.T) {
	t.Parallel()

	ctx := context.Background()

	existingDevice := &entity.Device{
		ID:         uuid.New(),
		HardwareID: "hw-get-001",
		Name:       "Test Device G",
		Metadata:   map[string]any{"status": "active"},
		CreatedAt:  time.Now(),
		UpdatedAt:  time.Now(),
	}

	tests := []struct {
		name          string
		desc          string
		deviceID      uuid.UUID
		repoSetup     func(*FakeDeviceRepository)
		wantOutput    *usecase.DeviceOutput
		wantErr       bool
		wantErrString string
	}{
		{
			name:     "success: get an existing device",
			desc:     "Verify that an existing device can be retrieved successfully by ID.",
			deviceID: existingDevice.ID,
			repoSetup: func(repo *FakeDeviceRepository) {
				repo.devices[existingDevice.ID] = existingDevice
			},
			wantOutput: &usecase.DeviceOutput{
				ID:         existingDevice.ID,
				HardwareID: existingDevice.HardwareID,
				Name:       existingDevice.Name,
				Metadata:   existingDevice.Metadata,
				CreatedAt:  existingDevice.CreatedAt,
				UpdatedAt:  existingDevice.UpdatedAt,
			},
			wantErr:       false,
			wantErrString: "",
		},
		{
			name:          "failure: device not found",
			desc:          "Verify that a 'device not found' error is returned when searching for a non-existent ID.",
			deviceID:      uuid.New(), // non-existing ID
			repoSetup:     nil,
			wantOutput:    nil,
			wantErr:       true,
			wantErrString: entity.ErrDeviceNotFound.Error(),
		},
		{
			name:     "failure: repository returns a generic error",
			desc:     "Verify that an unexpected error from the repository is propagated.",
			deviceID: uuid.New(),
			repoSetup: func(repo *FakeDeviceRepository) {
				repo.FindErr = assert.AnError
			},
			wantOutput:    nil,
			wantErr:       true,
			wantErrString: assert.AnError.Error(),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			fakeRepo := NewFakeDeviceRepository()
			if tt.repoSetup != nil {
				tt.repoSetup(fakeRepo)
			}

			uc := usecase.NewDeviceUsecase(fakeRepo)

			got, err := uc.GetDevice(ctx, tt.deviceID)

			if tt.wantErr {
				require.Error(t, err)

				if tt.wantErrString != "" {
					require.Contains(t, err.Error(), tt.wantErrString)
				}

				require.Nil(t, got)
			} else {
				require.NoError(t, err)
				require.NotNil(t, got)
				require.Equal(t, tt.wantOutput.ID, got.ID)
				require.Equal(t, tt.wantOutput.HardwareID, got.HardwareID)
				require.Equal(t, tt.wantOutput.Name, got.Name)
				require.Equal(t, tt.wantOutput.Metadata, got.Metadata)
			}
		})
	}
}

// TestListDevices tests the ListDevices method.
func TestListDevices(t *testing.T) {
	t.Parallel()

	ctx := context.Background()

	device1 := &entity.Device{
		ID:         uuid.New(),
		HardwareID: "hw-list-001",
		Name:       "Device 1",
		Metadata:   nil,
		CreatedAt:  time.Now(),
		UpdatedAt:  time.Now(),
	}
	device2 := &entity.Device{
		ID:         uuid.New(),
		HardwareID: "hw-list-002",
		Name:       "Device 2",
		Metadata:   nil,
		CreatedAt:  time.Now(),
		UpdatedAt:  time.Now(),
	}

	tests := []struct {
		name          string
		desc          string
		repoSetup     func(*FakeDeviceRepository)
		wantOutput    []*usecase.DeviceOutput
		wantErr       bool
		wantErrString string
	}{
		{
			name: "success: list all devices",
			desc: "Verify that all existing devices are listed correctly when multiple devices exist.",
			repoSetup: func(repo *FakeDeviceRepository) {
				repo.devices[device1.ID] = device1
				repo.devices[device2.ID] = device2
			},
			wantOutput: []*usecase.DeviceOutput{
				usecase.NewDeviceOutput(device1),
				usecase.NewDeviceOutput(device2),
			},
			wantErr:       false,
			wantErrString: "",
		},
		{
			name: "success: no devices exist",
			desc: "Verify that an empty list is returned when no devices exist.",
			repoSetup: func(repo *FakeDeviceRepository) {
				// No devices in repo
			},
			wantOutput:    []*usecase.DeviceOutput{},
			wantErr:       false,
			wantErrString: "",
		},
		{
			name: "failure: repository returns an error",
			desc: "Verify that the use case returns an error when the repository's FindAll method returns an error.",
			repoSetup: func(repo *FakeDeviceRepository) {
				repo.FindAllErr = assert.AnError
			},
			wantOutput:    nil,
			wantErr:       true,
			wantErrString: assert.AnError.Error(),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			fakeRepo := NewFakeDeviceRepository()
			if tt.repoSetup != nil {
				tt.repoSetup(fakeRepo)
			}

			uc := usecase.NewDeviceUsecase(fakeRepo)

			got, err := uc.ListDevices(ctx)

			if tt.wantErr {
				require.Error(t, err)

				if tt.wantErrString != "" {
					require.Contains(t, err.Error(), tt.wantErrString)
				}

				require.Nil(t, got)
			} else {
				require.NoError(t, err)
				// Sort slices for consistent comparison
				sort.Slice(got, func(i, j int) bool {
					return got[i].ID.String() < got[j].ID.String()
				})
				sort.Slice(tt.wantOutput, func(i, j int) bool {
					return tt.wantOutput[i].ID.String() < tt.wantOutput[j].ID.String()
				})
				require.Equal(t, tt.wantOutput, got)
			}
		})
	}
}

// TestUpdateDevice tests the UpdateDevice method.
func TestUpdateDevice(t *testing.T) {
	t.Parallel()

	ctx := context.Background()

	existingDevice := &entity.Device{
		ID:         uuid.New(),
		HardwareID: "hw-update-001",
		Name:       "Old Name",
		Metadata:   map[string]any{"status": "inactive"},
		CreatedAt:  time.Now(),
		UpdatedAt:  time.Now(),
	}
	updatedName := "New Name"
	updatedMetadata := map[string]any{"status": "active"}

	tests := []struct {
		name          string
		desc          string
		input         usecase.UpdateDeviceInput
		repoSetup     func(*FakeDeviceRepository)
		wantOutput    *usecase.DeviceOutput
		wantErr       bool
		wantErrString string
	}{
		{
			name: "success: update device name and metadata",
			desc: "Verify that the name and metadata of an existing device are updated correctly.",
			input: usecase.UpdateDeviceInput{
				ID:       existingDevice.ID,
				Name:     &updatedName,
				Metadata: updatedMetadata,
			},
			repoSetup: func(repo *FakeDeviceRepository) {
				repo.devices[existingDevice.ID] = existingDevice
			},
			wantOutput: &usecase.DeviceOutput{
				ID:         existingDevice.ID,
				HardwareID: existingDevice.HardwareID,
				Name:       updatedName,
				Metadata:   updatedMetadata,
				CreatedAt:  existingDevice.CreatedAt,
				UpdatedAt:  existingDevice.UpdatedAt,
			},
			wantErr:       false,
			wantErrString: "",
		},
		{
			name: "failure: target device not found",
			desc: "Verify that a 'device not found' error is returned when the target device ID does not exist.",
			input: usecase.UpdateDeviceInput{
				ID:       uuid.New(), // non-existing ID
				Name:     &updatedName,
				Metadata: nil,
			},
			repoSetup:     nil,
			wantOutput:    nil,
			wantErr:       true,
			wantErrString: entity.ErrDeviceNotFound.Error(),
		},
		{
			name: "failure: repository returns error on FindByID",
			desc: "Verify that an error from FindByID is propagated.",
			input: usecase.UpdateDeviceInput{
				ID:       existingDevice.ID,
				Name:     &updatedName,
				Metadata: nil,
			},
			repoSetup: func(repo *FakeDeviceRepository) {
				repo.FindErr = assert.AnError
			},
			wantOutput:    nil,
			wantErr:       true,
			wantErrString: assert.AnError.Error(),
		},
		{
			name: "failure: repository returns error on Save",
			desc: "Verify that an error from Save is propagated.",
			input: usecase.UpdateDeviceInput{
				ID:       existingDevice.ID,
				Name:     &updatedName,
				Metadata: nil,
			},
			repoSetup: func(repo *FakeDeviceRepository) {
				repo.devices[existingDevice.ID] = existingDevice
				repo.SaveErr = assert.AnError
			},
			wantOutput:    nil,
			wantErr:       true,
			wantErrString: assert.AnError.Error(),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			fakeRepo := NewFakeDeviceRepository()
			if tt.repoSetup != nil {
				tt.repoSetup(fakeRepo)
			}

			uc := usecase.NewDeviceUsecase(fakeRepo)

			got, err := uc.UpdateDevice(ctx, tt.input)

			if tt.wantErr {
				require.Error(t, err)

				if tt.wantErrString != "" {
					require.Contains(t, err.Error(), tt.wantErrString)
				}

				require.Nil(t, got)
			} else {
				require.NoError(t, err)
				require.NotNil(t, got)
				require.Equal(t, tt.wantOutput.ID, got.ID)
				require.Equal(t, tt.wantOutput.HardwareID, got.HardwareID)
				require.Equal(t, tt.wantOutput.Name, got.Name)
				require.Equal(t, tt.wantOutput.Metadata, got.Metadata)

				// Check the state of the fake repository
				savedDevice, findErr := fakeRepo.FindByID(ctx, got.ID)
				require.NoError(t, findErr)
				require.NotNil(t, savedDevice)
				require.Equal(t, updatedName, savedDevice.Name)
				require.Equal(t, entity.JSONBMap(updatedMetadata), savedDevice.Metadata)
			}
		})
	}
}

// TestDeleteDevice tests the DeleteDevice method.
func TestDeleteDevice(t *testing.T) {
	t.Parallel()

	ctx := context.Background()

	existingDevice := &entity.Device{
		ID:         uuid.New(),
		HardwareID: "hw-delete-001",
		Name:       "Test Device D",
		Metadata:   nil,
		CreatedAt:  time.Now(),
		UpdatedAt:  time.Now(),
	}

	tests := []struct {
		name          string
		desc          string
		deviceID      uuid.UUID
		repoSetup     func(*FakeDeviceRepository)
		wantErr       bool
		wantErrString string
	}{
		{
			name:     "success: delete a device",
			desc:     "Verify that a device is successfully deleted when a valid device ID is provided.",
			deviceID: existingDevice.ID,
			repoSetup: func(repo *FakeDeviceRepository) {
				repo.devices[existingDevice.ID] = existingDevice
			},
			wantErr:       false,
			wantErrString: "",
		},
		{
			name:          "failure: target device not found",
			desc:          "Verify that an error is returned when the target device to delete is not found.",
			deviceID:      uuid.New(), // non-existing ID
			repoSetup:     nil,
			wantErr:       true,
			wantErrString: entity.ErrDeviceNotFound.Error(),
		},

		{
			name:     "failure: repository returns error on Delete",
			desc:     "Verify that an error from Delete is propagated.",
			deviceID: existingDevice.ID,
			repoSetup: func(repo *FakeDeviceRepository) {
				repo.devices[existingDevice.ID] = existingDevice
				repo.DeleteErr = assert.AnError
			},
			wantErr:       true,
			wantErrString: assert.AnError.Error(),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			fakeRepo := NewFakeDeviceRepository()
			if tt.repoSetup != nil {
				tt.repoSetup(fakeRepo)
			}

			uc := usecase.NewDeviceUsecase(fakeRepo)

			err := uc.DeleteDevice(ctx, tt.deviceID)

			if tt.wantErr {
				require.Error(t, err)

				if tt.wantErrString != "" {
					require.Contains(t, err.Error(), tt.wantErrString)
				}
			} else {
				require.NoError(t, err)
				// Check the state of the fake repository
				_, findErr := fakeRepo.FindByID(ctx, tt.deviceID)
				require.ErrorIs(t, findErr, entity.ErrDeviceNotFound)
			}
		})
	}
}
